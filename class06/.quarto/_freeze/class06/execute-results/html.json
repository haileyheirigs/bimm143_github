{
  "hash": "8dfbfe1e08898d0598440193669a62fc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"class06\"\nauthor: \"Hailey Heirigs (PID: A16962278)\"\nformat: html\n---\n\n\n\n## Quarto\n\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.\n\n## Running Code\n\nWhen you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y){\n  x+y\n}\n```\n:::\n\n\n\n\nI can just use this function like any other function as long as R knows about it (i.e. run the code chunk)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(1, 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 101\n```\n\n\n:::\n:::\n\n\n\n## 1. R functions\n\nEvery R function has 3 things. \n- name (we get to pick this)\n- input arguments \n- the body \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y=10, z=0){\n  x+y+z\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n\nFunctions can have \"required\" input arguments and \"optional\" input arguments. The optional arguments are defined with an equals default value (`y=10`) in the function definition. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(x=1, y=100, z=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 111\n```\n\n\n:::\n:::\n\n\n\n> Q. Write a function to return a DNA sequence of a user specified length? Call it `generate_dna()` \n\nThe `sample()` function can help here\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#generate_dna <- function(size=5) { }\n\nstudents <- c(\"jeff\", \"jeremy\", \"peter\")\n\nsample(students, size = 5, replace=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"jeff\"   \"jeff\"   \"jeremy\" \"peter\"  \"jeremy\"\n```\n\n\n:::\n:::\n\n\n\n## 2. Generate DNA sequences\n\nNow work with `bases` rather than `students` \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbases <- c(\"A\", \"C\", \"G\", \"T\")\n\nsample(bases, size = 10, replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"C\" \"A\" \"G\" \"G\" \"G\" \"T\" \"G\" \"G\" \"T\" \"C\"\n```\n\n\n:::\n:::\n\n\n\nNow I have a working snippet of code & the body of my first function is here. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna <- function(size=5) {\n  bases <- c(\"A\", \"C\", \"G\", \"T\")\n  sample(bases, size=size, replace=TRUE)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] \"T\" \"T\" \"C\" \"A\" \"C\" \"G\" \"C\" \"T\" \"C\" \"G\" \"T\" \"T\" \"G\" \"A\" \"G\" \"A\" \"C\" \"G\"\n [19] \"C\" \"C\" \"A\" \"T\" \"C\" \"G\" \"C\" \"G\" \"G\" \"G\" \"G\" \"C\" \"C\" \"A\" \"A\" \"C\" \"C\" \"G\"\n [37] \"T\" \"T\" \"A\" \"A\" \"T\" \"A\" \"C\" \"C\" \"C\" \"A\" \"T\" \"C\" \"G\" \"A\" \"A\" \"T\" \"C\" \"T\"\n [55] \"C\" \"C\" \"G\" \"A\" \"A\" \"C\" \"G\" \"A\" \"C\" \"A\" \"A\" \"G\" \"G\" \"C\" \"T\" \"A\" \"G\" \"G\"\n [73] \"G\" \"T\" \"T\" \"G\" \"G\" \"G\" \"T\" \"C\" \"G\" \"A\" \"C\" \"A\" \"C\" \"T\" \"C\" \"G\" \"G\" \"T\"\n [91] \"A\" \"G\" \"A\" \"C\" \"T\" \"T\" \"A\" \"T\" \"G\" \"T\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"T\" \"C\" \"A\" \"T\" \"T\"\n```\n\n\n:::\n:::\n\n\n\nI want the ability to return a sequence like \"AGTACCTG\" i.e. a one element vector where the bases are all together. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna <- function(size=5, together=TRUE) {\n  bases <- c(\"A\", \"C\", \"G\", \"T\")\n  sequence <- sample(bases, size=size, replace=TRUE)\n  if(together) {\n    sequence <- paste(sequence, collapse = \"\")\n  }\n  return(sequence)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"GACTA\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna(together=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"G\" \"C\" \"T\" \"G\" \"A\"\n```\n\n\n:::\n:::\n\n\n\n## 3. Generate Protein function\n\n> Q. Write a protein sequence generating function that will return sequences of a user specified length? \n\nWe can get the set of 20 natural amino-acids from the **bio3d** package. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naa <- bio3d::aa.table$aa1[1:20]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naa\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"R\" \"N\" \"D\" \"C\" \"Q\" \"E\" \"G\" \"H\" \"I\" \"L\" \"K\" \"M\" \"F\" \"P\" \"S\" \"T\" \"W\" \"Y\"\n[20] \"V\"\n```\n\n\n:::\n:::\n\n\n\nand use this in our function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_protein <- function(size=6, together=TRUE) {\n  ## Get the 20 amino-acids as a vector\n  aa <- bio3d::aa.table$aa1[1:20]\n  sequence <- sample(aa, size, replace=TRUE)\n  \n  ## Optionally return a single element string \n  if(together){\n    sequence <- paste(sequence, collapse = \"\")\n  }\n  return(sequence)\n}\n```\n:::\n\n\n\n> Q. Generate random protein sequences of length 6 to 12 amino acids.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_protein(7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"GMVFAPT\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngenerate_protein(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"MNCPIHDA\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngenerate_protein(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"EFSWEVLRV\"\n```\n\n\n:::\n:::\n\n\n\n\nWe can fix this inability to generate multiple sequences by either editing and adding to the function body code (e.g. a for loop) or by using the R **apply** family of utility functions. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(6:12, generate_protein)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ACNQMT\"       \"VCYSVPV\"      \"VKLFALIN\"     \"LIKTMEYDM\"    \"GYNIQTLREE\"  \n[6] \"AIIQGAPGYPS\"  \"CFYVRPHVHNTW\"\n```\n\n\n:::\n:::\n\n\n\n> Q. Determine if these sequences can be found in nature or are they unique? Why or why not? \n\nIt would be cool and useful if I could get FASTA format output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nans <- sapply(6:12, generate_protein)\nans\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HVFNMN\"       \"HDINVRE\"      \"VSIGAFFF\"     \"LKADCVIEQ\"    \"TLQKGMPESD\"  \n[6] \"SPEQGEFQPYR\"  \"QLDTRVCTAQRG\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(ans, sep=\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHVFNMN\nHDINVRE\nVSIGAFFF\nLKADCVIEQ\nTLQKGMPESD\nSPEQGEFQPYR\nQLDTRVCTAQRG\n```\n\n\n:::\n:::\n\n\nI want this to look like\n\n```\n>ID.6\nQCRAWKLHID\n>ID.7\nTYNVGCMDFNT\n>ID.8\nEVLPAFWHLWIV\n```\n\nThe functions `paste()` and cat()` can help us here... \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nans2 <-paste(\">ID.\", 7:12, \"\\n\",ans, sep=\"\")\ncat(ans2, sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n>ID.7\nHVFNMN\n>ID.8\nHDINVRE\n>ID.9\nVSIGAFFF\n>ID.10\nLKADCVIEQ\n>ID.11\nTLQKGMPESD\n>ID.12\nSPEQGEFQPYR\n>ID.7\nQLDTRVCTAQRG\n```\n\n\n:::\n:::\n\n\n\n> Q. Determine if these sequences can be found in nature or are they unique? Why or why not? \n\nI BLASTp searched my FASTA format sequences against NR and found that lengths 6, 7, 8, are not unique and can be found in the databases with 100% coverage and 100% identity. \n\nRandom sequences of length 9 and above are unique and can't be found in the databases. \n\n\nYou can add options to executable code like this\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\nThe `echo: false` option disables the printing of code (only output is displayed).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1+1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n",
    "supporting": [
      "class06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}